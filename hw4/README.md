# Распределенная реляционная база Citus

## История

Компанию `Citus Data` основали в 2011 году три выпускника Стэнфорда, которые собрались после выпуска с общей болью в виде `NoSQL` баз данных. Ведь их масштабируемость следует из потери большинства преимуществ реляционных баз данных. Для упрощения разработчки они решили использовать в качестве основы `PostgreSQL`. В 2014 году добавлена поддержка колончатую базу данных для аналитики. В 2015-2016 частично вышли в OpenSource. В 2019 компания была приобретена `Microsoft` не меняя формат распределния продукта, вместе с этим появилась поддержка `Azure Database`. В 2022 году все возможности стали общедоступными. Сейчас продолжается бурное развитие как `PostgreSQL`, так и `Citus`.

## Инструмены взаимодействия

Базу возможно развенуть как на кластере, так и в облаке. Доступна возможность запросов через CLI, так и через специальне бибилиотеки в различных языках программирования вроде `Python`, `Java`. Также есть поддержка от популярных фреймворков вроде `Django`, `Ruby on Rails`.

## database engine

В качетсве движка используется `PostgreSQL`, который является реляционной базой данных. `Citus` позволяет добиться удобного шардирования и параллельности в запросах. Привнося горизонтальное масштабирование в экосистему `PostgreSQL`.

## Язык запросов, примеры

Для запросов используется обычный `SQL`. Однако при создании таблицы нужно дополнительно писать по какой колонке ее шардировать.

Доступен `docker` образ для данной СУБД.

`docker run -d --name citus -p 5432:5432 -e POSTGRES_PASSWORD=password citusdata/citus:latests`.

Затем можно создать таблицы аналогично `PostgreSQL`.

```sql
CREATE TABLE companies (
    id bigint NOT NULL,
    ...
);

CREATE TABLE campaigns (
    id bigint NOT NULL,
    company_id bigint NOT NULL,
    ...
);

CREATE TABLE ads (
    id bigint NOT NULL,
    company_id bigint NOT NULL,
    ...
);
```

А затем нужно сделать таблицы распределенными с помощью:

```sql
SELECT create_distributed_table('companies', 'id');
SELECT create_distributed_table('campaigns', 'company_id');
SELECT create_distributed_table('ads', 'company_id');
```

После чего можно работать с кластером как с одной нодой `PostgreSQL`, используя классический синтаксис `SQL` (`SELECT * FROM ads;`).

Однако в этом случае каждый отдельный запрос будет выполняться отдельно от других, что может привести к бесполезной транспортировки данных с матсера на подчиненных, для этого можно завернуть серию запросов в функцию, которая будет полностью выполнена, а лишь затем отдана мастеру:

```sql
SELECT create_distributed_function(
  'some_func(int, int)', 'company_id',
  colocate_with := 'campaigns'
);
```

## Распределенние файлов

`Citus` реализует удобный способ шардирования таблиц `PostgreSQL`. Все происходит автоматически, нужно лишь указать переменную по которой произойдет разделение. Таким образом данные расположены на разных носителях.

## Язык программирования СУБД

В открытом [https://github.com/citusdata/citus](репозитории) можно наблюдать, что больше всего кода написано на `C`. Остальное реализует бибилиотеки для удобного взаимодейтсвия с базой.

## Типы индексов

Индексация унаследована из `PostgreSQL`, а значит доступны: B-tree, hash, GiST, SP-GiST, GIN, and BRIN. А также поддерживается возможность настройки собственных механизмов индексации.

Пример:

```sql
CREATE INDEX index_name ON table_name USING B-tree[OR OTHERS] (column_name);
```

## Процесс выполнения запросов

Запрос приходит на кординатора, которая владеет информацией о шардировании и рабочих нодах. Затем он распределяется на подчиненных для исполнения. Остальное реализовано уже самим `PostgreSQL`. Все общение происходит через мастер ноду.

## План запроса

Планировка запроса также аналогична `PostgreSQL`, однако есть важное отличие. Оно подстраивается для распределенного исполнения на множестве рабоих нод. Запрос разбивается на операции, которые можно исполнить независимо на каждой из нод, а также на часть, которая должна исполнятся со всеми данными. Первая часть исполняется на рабочих, а вторая на координаторе.

Если же запрос затрагивает лишь одну рабочую ноду, то координатор определяет его и перенаправляет запрос ему.

## Транзакции

Поддерживаются транзакции аналогичные `PostgreSQL`. Координатор запускает транзакции в каждой затронутой ноде, а также свою, которая их обьединяет. Когда все рабочие ноды поддтверждают транзацию с помощью протокола `2PC`, то она завершается на кординаторе.

## Методы восстановления

Для восстановления можно использовать подходы: `High-Availability`, `Disaster Recovery`.

В первом случае все данные копируются на вспомогательную базу, в случае аварии можно взять backup оттуда.

Во втором случае мы храним таблицу изменений данных, с помощью которых можно откатываться на любой момент развития.

## Шардинг

Для шардинга используется разбиение по строкам по набору полей. Шардинг поддерживается и исполняется координатором автоматически, никакого вмешательства администратора не требуется.

## Data Mining, Data Warehousing, OLAP

Так как за основу взят `PostgreSQL`, то Data Warehousing очевидно одно из лучших применений, так как речь о реляционной базе данных.

Однако с помощью распределенной системы и поддержки запросов по колонкам `Citus` можно использовать и для аналитики, то есть `Data Mining`.

Однако для `OLAP` система плохо подходит, так как имеет жесткую структуру данных из `PostgreSQL` и хорошую нормализацию данных. Хоть запросы сложной агрегации будут значительно укорены распределенностью системы, но на мой взгляд это все равно не является оптимальны использованием данного решения.

## Методы шифрования

Все данные шифруются на кластере, а подключение возможно только по защищенному протоколу `TLS`. Возможно подкючение по `ssh` для которого поддерживается двухфакторая аутентификация, также доступна авторизация через `Google Authenticator`.

## Разработчики

На данный момент проект принадлежит компании `Microsoft`(в представлении не нуждается) и распространяется по лицензии `AGPL v.3`. В разработке могут учавствовать все пользователи сообщесвта. Для этого можно просить необходимую функциональность через `github issues`, либо добавлять ее самостоятельно, а затем отправлять разработчикам на кодревью.

Так как за основу взята крайне популярная СУБД `PostgreSQL`, то есть плотное сотрудничество между сообществами, а также компания инвестирует часть своих доходов в развитие `PostgreSQL`.

## Собственные данные

В качестве данных используем данные, собранные с помощью API к компьютерной игре `league of legends`. Соберем данные о наборе игр, в которых учавствовал я с помощью `scrapper.py`. Таблицы описаны в `ddl.sql`, а данные вставим с помощью `inserts.sql`.

Для этой базы можно придумать множество тригеров, которые с помощью `citus` можно исполнять на каждой рабочей ноде независимо. Также здесь большой простор для создания всевозможных функций и обработки данных. Если собрать еще записей с помощью `API`, то можно проводить довольно масштабную аналитику по тому, как играют люди(на ком и какие сборки используют).

Примеры запросов:

```sql
-- Список персонажей, которыми играют чаще всего, опуская из вывода самых редких
select champion_nm as char_name, count(*) as picks
from mh.summoner
         join mh.champion using (champion_id)
group by champion_id, champion_nm
having count(*) > 2
order by picks desc;
  char_name   | picks 
--------------+-------
 AurelionSol  |    15
 Camille      |     7
 Caitlyn      |     6
 Gangplank    |     5
 Jhin         |     5
 Xayah        |     5
 Yasuo        |     4
 Riven        |     4
 Ahri         |     4
 Ashe         |     3
 MissFortune  |     3
 Pyke         |     3
 Ezreal       |     3
 Diana        |     3
 Aatrox       |     3
 Zeri         |     3
 Senna        |     3
 JarvanIV     |     3
 Udyr         |     3
 Irelia       |     3
 Fiddlesticks |     3
 Seraphine    |     3
 Mordekaiser  |     3
 Yuumi        |     3
 Karma        |     3
 Evelynn      |     3
 Viego        |     3
(27 rows)
```

Или:

```sql
-- Отранжируем игроков по каждому серверу по их рейтингу
select champion_nm as char_name, count(*) as picks
from mh.summoner
         join mh.champion using (champion_id)
group by champion_id, champion_nm
having count(*) > 2
order by picks desc;
  char_name   | picks 
--------------+-------
 AurelionSol  |    15
 Camille      |     7
 Caitlyn      |     6
 Gangplank    |     5
 Jhin         |     5
 Xayah        |     5
 Yasuo        |     4
 Riven        |     4
 Ahri         |     4
 Ashe         |     3
 MissFortune  |     3
 Pyke         |     3
 Ezreal       |     3
 Diana        |     3
 Aatrox       |     3
 Zeri         |     3
 Senna        |     3
 ...
```

Напишем функцию и добавим ее в `citus`.

```sql
-- Функция для создания s̶t̶r̶i̶k̶e̶t̶h̶r̶o̶u̶g̶h̶ строк нужна для
create or replace function strike_through(str text) returns text as
$$
    return '\u0336'.join(str) + '\u0336';
$$ language plpython3u;

SELECT create_distributed_function(
  'strike_through(TEXT)', 'TEXT',
);
```

## Документация и обучение

- Документация доступна на официальнос сайте [citudata](https://www.citusdata.com). Там же существует и набор туториалов, которые помогают быстро освоиться.
- На гитхаб [репозитории](https://github.com/citusdata/citus) также можно найти примеры использования, а также открытый код. В случае проблем можно обращаться в `slack` сообщества, а также заводить тикеты в `github`.
- Так как продукт в открытом доступе и достатоно популярен, ведь он является частью сообщества `PostgreSQL`, то существует множество видео на `youtube` по любой теме.

## Новости

Аналогично прошлому пункту, на официальном сайте можно найти страничку с [поддержкой](https://www.citusdata.com/support), регулярными [подкастами](https://www.citusdata.com/podcast/path-to-citus-con/) и [новостной летной](https://www.citusdata.com/blog/) разработчиков.
